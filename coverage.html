
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cheat-go: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">cheat-go/main.go (76.7%)</option>
				
				<option value="file1">cheat-go/pkg/apps/registry.go (96.5%)</option>
				
				<option value="file2">cheat-go/pkg/apps/types.go (100.0%)</option>
				
				<option value="file3">cheat-go/pkg/config/loader.go (92.9%)</option>
				
				<option value="file4">cheat-go/pkg/config/types.go (100.0%)</option>
				
				<option value="file5">cheat-go/pkg/ui/table.go (100.0%)</option>
				
				<option value="file6">cheat-go/pkg/ui/theme.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "os"

        tea "github.com/charmbracelet/bubbletea"

        "cheat-go/pkg/apps"
        "cheat-go/pkg/config"
        "cheat-go/pkg/ui"
)

type model struct {
        registry *apps.Registry
        config   *config.Config
        renderer *ui.TableRenderer
        rows     [][]string
        cursorX  int
        cursorY  int
}

func initialModel() model <span class="cov8" title="1">{
        // Load configuration
        loader := config.NewLoader("")
        cfg, err := loader.Load()
        if err != nil </span><span class="cov0" title="0">{
                // Log error but continue with defaults
                fmt.Fprintf(os.Stderr, "Warning: Could not load config (%v), using defaults\n", err)
                cfg = config.DefaultConfig()
        }</span>

        // Initialize app registry
        <span class="cov8" title="1">registry := apps.NewRegistry(cfg.DataDir)
        if err := registry.LoadApps(cfg.Apps); err != nil </span><span class="cov0" title="0">{
                // Log warning but continue with hardcoded data
                fmt.Fprintf(os.Stderr, "Warning: Could not load some apps (%v), using defaults\n", err)
        }</span>

        // Create theme and renderer
        <span class="cov8" title="1">theme := ui.GetTheme(cfg.Theme)
        renderer := ui.NewTableRenderer(theme)

        // Generate table data
        rows := registry.GetTableData(cfg.Apps)

        return model{
                registry: registry,
                config:   cfg,
                renderer: renderer,
                rows:     rows,
                cursorX:  0,
                cursorY:  1,
        }</span>
}

func (m model) Init() tea.Cmd <span class="cov8" title="1">{
        return nil
}</span>

func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov8" title="1">
                switch msg.String() </span>{
                case "ctrl+c", "q":<span class="cov8" title="1">
                        return m, tea.Quit</span>
                case "up", "k":<span class="cov8" title="1">
                        if m.cursorY &gt; 1 </span><span class="cov8" title="1">{
                                m.cursorY--
                        }</span>
                case "down", "j":<span class="cov8" title="1">
                        if m.cursorY &lt; len(m.rows)-1 </span><span class="cov8" title="1">{
                                m.cursorY++
                        }</span>
                case "left", "h":<span class="cov8" title="1">
                        if m.cursorX &gt; 0 </span><span class="cov8" title="1">{
                                m.cursorX--
                        }</span>
                case "right", "l":<span class="cov8" title="1">
                        if m.cursorX &lt; len(m.rows[0])-1 </span><span class="cov8" title="1">{
                                m.cursorX++
                        }</span>
                }
        }
        <span class="cov8" title="1">return m, nil</span>
}

func (m model) View() string <span class="cov8" title="1">{
        return m.renderer.RenderWithInstructions(m.rows, m.cursorX, m.cursorY)
}</span>

func main() <span class="cov0" title="0">{
        p := tea.NewProgram(initialModel())
        if err := p.Start(); err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error running program:", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package apps

import (
        "errors"
        "os"
        "path/filepath"

        "gopkg.in/yaml.v3"
)

var (
        ErrAppNotFound    = errors.New("application not found")
        ErrInvalidAppFile = errors.New("invalid app file format")
)

// Registry manages application loading and registration
type Registry struct {
        *AppRegistry
        dataDir string
}

// NewRegistry creates a new registry with default hardcoded apps
func NewRegistry(dataDir string) *Registry <span class="cov8" title="1">{
        registry := &amp;Registry{
                AppRegistry: NewAppRegistry(),
                dataDir:     dataDir,
        }

        // Load hardcoded apps as fallback
        registry.loadHardcodedApps()

        return registry
}</span>

// LoadApps loads applications from configuration
func (r *Registry) LoadApps(appNames []string) error <span class="cov8" title="1">{
        for _, name := range appNames </span><span class="cov8" title="1">{
                if err := r.LoadApp(name); err != nil </span><span class="cov8" title="1">{
                        // If loading from file fails, use hardcoded data
                        continue</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// LoadApp loads a single application from file or hardcoded data
func (r *Registry) LoadApp(name string) error <span class="cov8" title="1">{
        // Try to load from file first
        if r.dataDir != "" </span><span class="cov8" title="1">{
                appPath := filepath.Join(r.dataDir, name+".yaml")
                if app, err := r.loadAppFromFile(appPath); err == nil </span><span class="cov8" title="1">{
                        r.Register(app)
                        return nil
                }</span>
        }

        // If file loading fails, app should already be loaded from hardcoded data
        <span class="cov8" title="1">if _, exists := r.Get(name); exists </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return ErrAppNotFound</span>
}

// loadAppFromFile loads an app definition from a YAML file
func (r *Registry) loadAppFromFile(path string) (*App, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var app App
        if err := yaml.Unmarshal(data, &amp;app); err != nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidAppFile
        }</span>

        <span class="cov8" title="1">return &amp;app, nil</span>
}

// loadHardcodedApps loads the original hardcoded application data
func (r *Registry) loadHardcodedApps() <span class="cov8" title="1">{
        // Convert original table data to structured format
        shortcuts := []struct {
                key     string
                vim     string
                zsh     string
                dwm     string
                st      string
                lf      string
                zathura string
        }{
                {"h", "← move", "back char", "focus left", "← move", "left", "scroll ←"},
                {"l", "→ move", "forward char", "focus right", "→ move", "right", "scroll →"},
                {"j", "↓ move", "down history", "focus down", "↓ scroll", "down", "scroll ↓"},
                {"k", "↑ move", "up history", "focus up", "↑ scroll", "up", "scroll ↑"},
                {"gg", "top", "-", "-", "-", "top", "-"},
                {"G", "bottom", "-", "-", "-", "bottom", "-"},
                {"/", "search", "search history", "-", "search", "search", "search"},
                {":", "command", "prompt", "command", "-", "command", "-"},
                {"q", "quit", "exit", "close win", "exit", "quit", "quit"},
        }

        // Create apps from hardcoded data
        apps := map[string]*App{
                "vim": {
                        Name:        "vim",
                        Description: "Vi IMproved text editor",
                        Version:     "1.0",
                        Categories:  []string{"editor"},
                        Shortcuts:   []Shortcut{},
                },
                "zsh": {
                        Name:        "zsh",
                        Description: "Z Shell",
                        Version:     "1.0",
                        Categories:  []string{"shell"},
                        Shortcuts:   []Shortcut{},
                },
                "dwm": {
                        Name:        "dwm",
                        Description: "Dynamic window manager",
                        Version:     "1.0",
                        Categories:  []string{"wm"},
                        Shortcuts:   []Shortcut{},
                },
                "st": {
                        Name:        "st",
                        Description: "Simple terminal",
                        Version:     "1.0",
                        Categories:  []string{"terminal"},
                        Shortcuts:   []Shortcut{},
                },
                "lf": {
                        Name:        "lf",
                        Description: "Terminal file manager",
                        Version:     "1.0",
                        Categories:  []string{"file-manager"},
                        Shortcuts:   []Shortcut{},
                },
                "zathura": {
                        Name:        "zathura",
                        Description: "Document viewer",
                        Version:     "1.0",
                        Categories:  []string{"viewer"},
                        Shortcuts:   []Shortcut{},
                },
        }

        // Populate shortcuts for each app
        for _, shortcut := range shortcuts </span><span class="cov8" title="1">{
                descriptions := []string{shortcut.vim, shortcut.zsh, shortcut.dwm, shortcut.st, shortcut.lf, shortcut.zathura}
                appNames := []string{"vim", "zsh", "dwm", "st", "lf", "zathura"}

                for i, desc := range descriptions </span><span class="cov8" title="1">{
                        if desc != "-" &amp;&amp; desc != "" </span><span class="cov8" title="1">{
                                apps[appNames[i]].Shortcuts = append(apps[appNames[i]].Shortcuts, Shortcut{
                                        Keys:        shortcut.key,
                                        Description: desc,
                                        Category:    "general",
                                })
                        }</span>
                }
        }

        // Register all apps
        <span class="cov8" title="1">for _, app := range apps </span><span class="cov8" title="1">{
                r.Register(app)
        }</span>
}

// GetTableData returns data in the original table format for backward compatibility
func (r *Registry) GetTableData(appNames []string) [][]string <span class="cov8" title="1">{
        // Header row
        header := make([]string, len(appNames)+1)
        header[0] = "Shortcut"
        copy(header[1:], appNames)

        // Collect all unique shortcuts
        shortcutMap := make(map[string][]string)
        for i, appName := range appNames </span><span class="cov8" title="1">{
                if app, exists := r.Get(appName); exists </span><span class="cov8" title="1">{
                        for _, shortcut := range app.Shortcuts </span><span class="cov8" title="1">{
                                if _, exists := shortcutMap[shortcut.Keys]; !exists </span><span class="cov8" title="1">{
                                        shortcutMap[shortcut.Keys] = make([]string, len(appNames))
                                        for j := range shortcutMap[shortcut.Keys] </span><span class="cov8" title="1">{
                                                shortcutMap[shortcut.Keys][j] = "-"
                                        }</span>
                                }
                                <span class="cov8" title="1">shortcutMap[shortcut.Keys][i] = shortcut.Description</span>
                        }
                }
        }

        // Convert to table format
        <span class="cov8" title="1">rows := [][]string{header}
        for keys, descriptions := range shortcutMap </span><span class="cov8" title="1">{
                row := make([]string, len(appNames)+1)
                row[0] = keys
                copy(row[1:], descriptions)
                rows = append(rows, row)
        }</span>

        <span class="cov8" title="1">return rows</span>
}

// expandPath expands ~ to home directory
func expandPath(path string) string <span class="cov8" title="1">{
        if len(path) == 0 || path[0] != '~' </span><span class="cov8" title="1">{
                return path
        }</span>

        <span class="cov8" title="1">home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return path
        }</span>

        <span class="cov8" title="1">return filepath.Join(home, path[1:])</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package apps

// App represents a single application with its shortcuts
type App struct {
        Name        string            `yaml:"name" json:"name"`
        Description string            `yaml:"description" json:"description"`
        Categories  []string          `yaml:"categories" json:"categories"`
        Shortcuts   []Shortcut        `yaml:"shortcuts" json:"shortcuts"`
        Metadata    map[string]string `yaml:"metadata" json:"metadata"`
        Version     string            `yaml:"version" json:"version"`
}

// Shortcut represents a single keyboard shortcut
type Shortcut struct {
        Keys        string   `yaml:"keys" json:"keys"`
        Description string   `yaml:"description" json:"description"`
        Category    string   `yaml:"category" json:"category"`
        Tags        []string `yaml:"tags" json:"tags"`
        Platform    string   `yaml:"platform,omitempty" json:"platform,omitempty"`
}

// AppRegistry holds all registered applications
type AppRegistry struct {
        apps map[string]*App
}

// NewAppRegistry creates a new app registry
func NewAppRegistry() *AppRegistry <span class="cov8" title="1">{
        return &amp;AppRegistry{
                apps: make(map[string]*App),
        }
}</span>

// Register adds an app to the registry
func (r *AppRegistry) Register(app *App) <span class="cov8" title="1">{
        r.apps[app.Name] = app
}</span>

// Get retrieves an app by name
func (r *AppRegistry) Get(name string) (*App, bool) <span class="cov8" title="1">{
        app, exists := r.apps[name]
        return app, exists
}</span>

// GetAll returns all registered apps
func (r *AppRegistry) GetAll() map[string]*App <span class="cov8" title="1">{
        return r.apps
}</span>

// List returns the names of all registered apps
func (r *AppRegistry) List() []string <span class="cov8" title="1">{
        names := make([]string, 0, len(r.apps))
        for name := range r.apps </span><span class="cov8" title="1">{
                names = append(names, name)
        }</span>
        <span class="cov8" title="1">return names</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package config

import (
        "errors"
        "os"
        "path/filepath"

        "gopkg.in/yaml.v3"
)

var (
        ErrConfigNotFound = errors.New("configuration file not found")
        ErrInvalidConfig  = errors.New("invalid configuration format")
)

// Loader handles configuration loading and validation
type Loader struct {
        configPath string
}

// NewLoader creates a new configuration loader
func NewLoader(configPath string) *Loader <span class="cov8" title="1">{
        return &amp;Loader{
                configPath: configPath,
        }
}</span>

// Load reads and parses the configuration file
func (l *Loader) Load() (*Config, error) <span class="cov8" title="1">{
        // Try to load from file first
        if l.configPath != "" </span><span class="cov8" title="1">{
                if config, err := l.loadFromFile(l.configPath); err == nil </span><span class="cov8" title="1">{
                        return config, nil
                }</span>
        }

        // Try default config locations
        <span class="cov8" title="1">defaultPaths := []string{
                "~/.config/cheat-go/config.yaml",
                "~/.cheat-go.yaml",
                "./config.yaml",
        }

        for _, path := range defaultPaths </span><span class="cov8" title="1">{
                expandedPath := expandPath(path)
                if config, err := l.loadFromFile(expandedPath); err == nil </span><span class="cov8" title="1">{
                        return config, nil
                }</span>
        }

        // Fall back to default configuration
        <span class="cov8" title="1">return DefaultConfig(), nil</span>
}

// loadFromFile loads configuration from a specific file
func (l *Loader) loadFromFile(path string) (*Config, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var config Config
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidConfig
        }</span>

        <span class="cov8" title="1">return l.validateAndSetDefaults(&amp;config)</span>
}

// validateAndSetDefaults validates config and sets defaults for missing values
func (l *Loader) validateAndSetDefaults(config *Config) (*Config, error) <span class="cov8" title="1">{
        defaults := DefaultConfig()

        // Set defaults for missing values
        if len(config.Apps) == 0 </span><span class="cov8" title="1">{
                config.Apps = defaults.Apps
        }</span>

        <span class="cov8" title="1">if config.Theme == "" </span><span class="cov8" title="1">{
                config.Theme = defaults.Theme
        }</span>

        <span class="cov8" title="1">if len(config.Layout.Columns) == 0 </span><span class="cov8" title="1">{
                config.Layout = defaults.Layout
        }</span>

        <span class="cov8" title="1">if len(config.Keybinds) == 0 </span><span class="cov8" title="1">{
                config.Keybinds = defaults.Keybinds
        }</span>

        <span class="cov8" title="1">if config.DataDir == "" </span><span class="cov8" title="1">{
                config.DataDir = defaults.DataDir
        }</span>

        <span class="cov8" title="1">return config, nil</span>
}

// Save writes the configuration to file
func (l *Loader) Save(config *Config, path string) error <span class="cov8" title="1">{
        data, err := yaml.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Ensure directory exists
        <span class="cov8" title="1">dir := filepath.Dir(path)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return os.WriteFile(path, data, 0644)</span>
}

// expandPath expands ~ to home directory
func expandPath(path string) string <span class="cov8" title="1">{
        if len(path) == 0 || path[0] != '~' </span><span class="cov8" title="1">{
                return path
        }</span>

        <span class="cov8" title="1">home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return path
        }</span>

        <span class="cov8" title="1">return filepath.Join(home, path[1:])</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package config

// Config represents the main application configuration
type Config struct {
        Apps     []string          `yaml:"apps" json:"apps"`
        Theme    string            `yaml:"theme" json:"theme"`
        Layout   LayoutConfig      `yaml:"layout" json:"layout"`
        Keybinds map[string]string `yaml:"keybinds" json:"keybinds"`
        DataDir  string            `yaml:"data_dir" json:"data_dir"`
}

// LayoutConfig controls the display layout
type LayoutConfig struct {
        Columns        []string `yaml:"columns" json:"columns"`
        ShowCategories bool     `yaml:"show_categories" json:"show_categories"`
        TableStyle     string   `yaml:"table_style" json:"table_style"`
        MaxWidth       int      `yaml:"max_width" json:"max_width"`
}

// DefaultConfig returns a default configuration
func DefaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                Apps:  []string{"vim", "zsh", "dwm", "st", "lf", "zathura"},
                Theme: "default",
                Layout: LayoutConfig{
                        Columns:        []string{"shortcut", "description"},
                        ShowCategories: false,
                        TableStyle:     "simple",
                        MaxWidth:       120,
                },
                Keybinds: map[string]string{
                        "quit":     "q",
                        "up":       "k",
                        "down":     "j",
                        "left":     "h",
                        "right":    "l",
                        "search":   "/",
                        "next_app": "tab",
                        "prev_app": "shift+tab",
                },
                DataDir: "~/.config/cheat-go/apps",
        }
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package ui

import (
        "strings"

        "github.com/mattn/go-runewidth"
)

// TableRenderer handles the rendering of tabular data
type TableRenderer struct {
        theme *Theme
}

// NewTableRenderer creates a new table renderer with the given theme
func NewTableRenderer(theme *Theme) *TableRenderer <span class="cov8" title="1">{
        return &amp;TableRenderer{
                theme: theme,
        }
}</span>

// Render renders a table from the given data with cursor position
func (r *TableRenderer) Render(rows [][]string, cursorX, cursorY int) string <span class="cov8" title="1">{
        if len(rows) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">var b strings.Builder

        // Determine column widths using runewidth
        colWidths := make([]int, len(rows[0]))
        for _, row := range rows </span><span class="cov8" title="1">{
                for i, cell := range row </span><span class="cov8" title="1">{
                        if w := runewidth.StringWidth(cell); w &gt; colWidths[i] </span><span class="cov8" title="1">{
                                colWidths[i] = w
                        }</span>
                }
        }

        // Render rows
        <span class="cov8" title="1">for y, row := range rows </span><span class="cov8" title="1">{
                for x, cell := range row </span><span class="cov8" title="1">{
                        cellWidth := runewidth.StringWidth(cell)
                        pad := colWidths[x] - cellWidth
                        content := " " + cell + strings.Repeat(" ", pad) + " "

                        style := r.theme.CellStyle
                        if y == 0 </span><span class="cov8" title="1">{
                                style = r.theme.HeaderStyle
                        }</span>
                        <span class="cov8" title="1">if x == cursorX &amp;&amp; y == cursorY </span><span class="cov8" title="1">{
                                style = style.Reverse(true)
                        }</span>

                        <span class="cov8" title="1">b.WriteString(style.Render(content))
                        if x &lt; len(row)-1 </span><span class="cov8" title="1">{
                                b.WriteString("│")
                        }</span>
                }
                <span class="cov8" title="1">b.WriteString("\n")

                // Add separator after header
                if y == 0 </span><span class="cov8" title="1">{
                        for i, w := range colWidths </span><span class="cov8" title="1">{
                                b.WriteString(strings.Repeat("─", w+2))
                                if i &lt; len(colWidths)-1 </span><span class="cov8" title="1">{
                                        b.WriteString("┼")
                                }</span>
                        }
                        <span class="cov8" title="1">b.WriteString("\n")</span>
                }
        }

        <span class="cov8" title="1">return b.String()</span>
}

// RenderWithInstructions renders the table with usage instructions
func (r *TableRenderer) RenderWithInstructions(rows [][]string, cursorX, cursorY int) string <span class="cov8" title="1">{
        table := r.Render(rows, cursorX, cursorY)
        return table + "\nUse arrow keys or hjkl to move. Press q to quit."
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package ui

import "github.com/charmbracelet/lipgloss"

// Theme defines the visual styling for the application
type Theme struct {
        HeaderStyle lipgloss.Style
        CellStyle   lipgloss.Style
        BorderColor lipgloss.Color
}

// DefaultTheme returns the default theme
func DefaultTheme() *Theme <span class="cov8" title="1">{
        return &amp;Theme{
                HeaderStyle: lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("205")),
                CellStyle:   lipgloss.NewStyle().Padding(0, 0),
                BorderColor: lipgloss.Color("240"),
        }
}</span>

// DarkTheme returns a dark theme variant
func DarkTheme() *Theme <span class="cov8" title="1">{
        return &amp;Theme{
                HeaderStyle: lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("39")),
                CellStyle:   lipgloss.NewStyle().Padding(0, 0),
                BorderColor: lipgloss.Color("238"),
        }
}</span>

// GetTheme returns a theme by name
func GetTheme(name string) *Theme <span class="cov8" title="1">{
        switch name </span>{
        case "dark":<span class="cov8" title="1">
                return DarkTheme()</span>
        default:<span class="cov8" title="1">
                return DefaultTheme()</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
